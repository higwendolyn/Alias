---
layout: post
title: "JS基础---数组原理（数组API）"
category: 'JavaScipt'
---

帮助梳理眼花缭乱的数组API，数组作为一个最基础的一维数据结构，角色至关重要。

问题1：
<font style="color: #ec7907;">数组的构造器有哪几种？</font>

问题2：
<font style="color: #ec7907;">哪些是改变自身的方法？</font>

问题3：
<font style="color: #ec7907;">哪些是不改变自身的方法？</font>

问题4：
<font style="color: #ec7907;">遍历的方法有哪些？</font>

## 数组概念的探究

<mark style="background: #e1c94799;">截止 ES7 规范，数组共包含 33 个标准的API方法和一个非标准的API方法</mark>

## Array 的构造器

Array 构造器用于创建一个新的数组，通常推荐使用对象字面量的方式创建一个数组

```javascript
// 使用 Array 构造器，可以自定义长度
var a = Array(6); // [undefined x 6]
// 使用对象字面量
var b = [];
b.length = 6; // [undefined x 6]
```

* new Array(arg1, arg2, ...) 参数长度为0或长度大于等于2时，传入的参数将按照顺序依次成为新数组的第0至第N项（参数长度为0时，返回空数组）
* new Array(len)当len不是数值时，处理同上，返回一个只包含len元素的一项的数组；当len为数值时，len最大不能超过32为无符号整型，即需要小于2的32次方（len最大为Math.pow(2, 32)），否则将抛出RangeError

## ES6新增的构造方法：Array.of 和Array.from

### Array.of

Array.of 用于将参数依次转化为数组中的一项，然后返回这个数组，而不管这个参数是数字还是其他

```javascript
Array.of(8.0); // [8]
Array(8.0); // [empty x 8]

Array.of(8.0, 5); // [8, 5]
Array(8.0, 5); // [8, 5]

Array.of('8'); // ['8']
Array('8'); // ['8']
```

### Array.from

Array.from 的设计初衷是快速便捷地基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象中创建一个新的数组实例

1. 类似数组的对象，必选
2. 加工函数，新生成的数组会经过该函数的加工再返回
3. this 作用域，表示加工函数执行时 this 的值

```javascript
var obj = {0: 'a', 1: 'b', 2: 'c', length: 3};
Array.from(obj, function(value, index){
    console.log(value, index, this, arguments.length);
    return value.repeat(3); // 必须指定返回值，否则返回 undefined
}, obj);
```

```javascript
Array.from(obj, (value) => value.repeat(3)); // 控制台返回(3)['aaa', 'bbb', 'ccc']
```

```javascript
// String
Array.from('abc'); // ['a', 'b', 'c']

// Set
Array.from(new Set(['abc', 'def'])); // ['abc', 'def']

// Map
Array.from(new Map([[1, 'ab'], [2, 'de']]));
// [[1, 'ab']], [2, 'de']]
```

## Array 的判断

Array.isArray 用来判断一个变量是否为数组类型

```javascript
var a = [];
// 1.基于instanceof
a instanceof Array;
// 2.基于constructor
a.constructor === Array;
// 3.基于Object.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(a);
// 4.基于getPrototypeOf
Object.getPrototypeOf(a) === Array.prototype;
// 5.基于Object.prototype.toString
Object.prototype.toString.apply(a) === 'object Array';
```

```javascript
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}
```

## 改变自身的方法

pop、push、reverse、shift、sort、splice、unshift 以及两个 ES6 新增的方法 copyWithin 和 fill

```javascript
// pop 方法
var array = ['cat', 'dog', 'cow', 'chicken', 'mouse'];
var item = array.pop();
console.log(array); // ['cat', 'dog', 'cow', 'chicken']
console.log(item); // mouse

// push 方法
var array = ['football','basketball','badminton'];
var i = array.push('golfball');
console.log(array);
// ['football','basketball','badminton','golfball']
console.log(i); // 4

// reverse 方法
var array = [1,2,3,4,5];
var array2 = array.reverse();
console.log(array); // [5,4,3,2,1]
console.log(array2 === array); // true

// shift方法
var array = [1,2,3,4,5];
var item = array.shift();
console.log(array); // [2,3,4,5]
console.log(item); // 1

// unshift方法
var array = ['red','green','blue'];
var length = array.unshift('yellow');
console.log(array); // ['yellow','red','green','blue']
console.log(length); // 4

// sort方法
var array = ['apple','Boy','Cat','dog'];
var array2 = array.sort();
console.log(array); // ['Boy','Cat','apple','dog']
console.log(array2 == array); // true

// splice方法
var array = ['apple', 'boy'];
var splices = array.splice(1,1);
console.log(array); // ['apple']
console.log(splices); // ['boy']

// copyWithin方法
var array = [1,2,3,4,5];
var array2 = array.copyWithin(0,3);
console.log(array === array2, array2); // true [4,5,3,4,5]

// fill方法
var array = [1,2,3,4,5];
var array2 = array.fill(10,0,3);
console.log(array === array2, array2);
// true [10,10,10,4,5], 可见数组区间[0,3]的元素全部替换为10
```


```javascript
给你两个有序整数数组 nums1 和nums2,请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

输入：
nums1 = [1,2,3,0,0,0]; m = 3
nums2 = [2,5,6]; n = 3
输出：[1,2,2,3,5,6]
```

```javascript
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m);
    nums2.splice(n);
    nums1.push(...nums2);
    nums1.sort((a,b) => a - b); // nums1从小到大排序，所以是 a - b
};
```

## 不改变自身的方法

concat、join、slice、toString、toLocalString、indexOf、lastIndexOf

未形成标准的 toSource

以及ES7新增的方法 includes


