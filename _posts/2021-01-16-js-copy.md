---
layout: post
title: "JS基础---深拷贝和浅拷贝"
---

JS的编程过程中经常需要对数据进行复制，什么时候用深拷贝、什么时候用浅拷贝？

问题1：
<font style="color: #ec7907;">拷贝一个很多嵌套的对象怎么实现？</font>

问题2：
<font style="color: #ec7907;">写成什么样是深拷贝代码才能算合格？</font>

## 浅拷贝的原理和实现

定义：自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定就会影响到另一个对象。


### Object.assign

Object.assign 是ES6中object的一个方法，该方法可以用于JS对象的合并等多个用途，其中一个用途就是可以进行浅拷贝

语法：```Object.assign(target, ...sources)```

```javascript
let target = {};
let source = { a: {b: 1} };

Object.assign(target, source);
console.log(target); // {a: {b: 1}}
```

```javascript
let target = {};
let source = { a: {b: 2} };
Object.assign(target, source);

console.log(target); // {a: {b: 10}}
source.a.b = 10;
console.log(source); // {a: {b: 10}}
console.log(target); // {a: {b: 10}}
```

<font style="color: red;">注意</font>

* 它不会拷贝对象的继承属性
* 它不会拷贝对象的不可枚举的属性
* 可以拷贝Symbol类型的属性

```javascript
let obj1 = {a: {b: 1}, sym: Symbol(1)};
Object.defineProperty(obj1, 'innumerabe', {
    value: '不可枚举属性',
    enumerable: false
});
let obj2 = {};
Object.assign(obj2, obj1)
obj1.a.b = 2;

console.log('obj1', obj1);
console.log('obj2', obj2);
```
---
### 扩展运算符方式

利用JS的扩展运算符，在构造对象的同时完成浅拷贝的功能

语法： let cloneObj = { ...obj };

```javascript
/* 对象的拷贝 */
let obj = { a: 1, b: { c: 1}}
let obj2 = { ...obj }
obj.a = 2
console.log(obj) // { a: 2, b: { c: 1}} console.log(obj2) // { a: 1, b: { c: 1}}
obj.b.c = 2
console.log(obj) // { a: 2, b: { c: 2}} console.log(obj2) // { a: 1, b: { c: 2}}

/* 数组的拷贝 */
let arr = [1, 2, 3];
let newArr = [...arr]; // 和arr.slice()是一样的效果
```
---
### concat拷贝数组

数组的concat方法其实也是浅拷贝

```javascript
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr); // [1, 2, 3]
console.log(newArr); // [1, 100, 3]
```

### slice拷贝数组

slice方法仅仅针对数组类型

slice的语法为：arr.slice(begin, end);

```javascript
let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;

console.log(arr); // [1, 2, {val: 1000}]
```

### 手工实现一个浅拷贝

1. 对基础类型做一个最基本的一个拷贝
2. 对引用类型开辟一个新的存储，并且拷贝一层对象属性

```javascript
const shallowClone = (target) => {
    if (typeof target === 'object' && target !== null) {
        const cloneTarget = Array.isArray(target) ? [] : {};
        for (let prop in target) {
            if (target.hasOwnProperty(prop)) {
                cloneTaregt[prop] = target[prop];
            }
        }
        return cloneTarget;
    } else {
        return target;
    }
}
```

## 深拷贝的原理和实现

浅拷贝：浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值

深拷贝：对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放

深拷贝定义：将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。

## 乞丐版（JSON.stringfy）

JSON.stringfy()是目前开发过程中最简单的深拷贝方法

```javascript
```