---
layout: post
title: "Webpack-—背景"
category: 'Webpack'
---

讲解模块化的发展史

## 模块化的演进过程

* Stage1 - 文件划分方式：根据功能、数据状态存放到不同的文件
> 缺点：
> * 模块直接在全局工作，大量模块成员污染全局作用域
> * 没有私有空间，所有模块内的成员都可以在模块外部被访问或者修改
> * 一旦模块增多，容易产生命名冲突
> * 无法管理模块之间的依赖关系
> * 在维护的过程中很难分辨每个成员所属的模块

* Stage2 - 命名空间方式：每个文件暴露出来是一个全局对象
> 解决命名冲突的问题，但其他问题依旧存在

* Stage3 - IIFE：每个模块的成员放到立即执行函数中，带来私有作用域概念，通过闭包访问
> 解决了命名冲突的问题

* Stage4 - IIFE 依赖参数：通过参数明显表面这个模块的依赖

模块加载问题：不受代码控制

<mark>理想的方式</mark>

在页面中引入一个 JS 入口文件，其余用到的模块可以通过代码控制，按需加载

### 模块化规范的出现

两点需求：
* 一个统一的模块化标准规范
* 一个可以自动加载模块的基础库

<font style="color: #ec7907;">CommonJS 规范</font>

* 是 Node.js 中所遵循的模块规范
* 约定一个文件就是一个模块，每个模块都有单独的作用域
* 通过 module.exports 导出成员，再通过 require 函数载入模块
* 以同步的方式加载模块（加载页面较慢），Node.js 是启动的时候加载模块（执行中再去使用模块）

<font style="color: #ec7907;">AMD 规范（异步模块定义规范）</font>

* 每个模块都通过 define 去定义

```javascript
define(['jquery', './module2.js'], function ($, module2) {
    return {
        start: function () {
            $('body').animate({ margin: '200px' })
            module2()
        }
    }
})
```

<font style="color: #ec7907;">模块化的标准规范</font>
* 在 Node.js 环境中，遵循 CommonJS 规范来组织模块
* 在浏览器环境中，遵循 ES Modules 规范

ES Modules 已发展成为现今最主流的前端模块化标准

## 模块打包工具的出现

* ES Modules 本身存在环境兼容问题
* 模块化的方式划分出来的模块文件过多，而前端应用又运行在浏览器中，导致频繁发送网络请求
* 不仅仅 JS 代码需要模块化，HTML、CSS 也面临需要模块化的问题

针对问题1、2，gulp和插件、编译工具即可

但是问题3，webpck可





