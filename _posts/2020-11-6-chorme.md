---
layout: post
title: "浏览器发展史与渲染进程"
---

重点解析**chorme**浏览器原理及其架构演变，解析浏览器内核**渲染进程**。

# 单进程浏览器
**单进程浏览器**是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。
>2007年之前，所有的浏览器都是单进程的，e.g. IE6。IE6时代，浏览器是单进程的，所有页面也都是运行在一个主线程中的，当时IE6就是这样设计，而且当时的IE6是单标签，也就是说一个页面一个窗口。
>
>页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。

**单进程的浏览器存在的问题**：
>1. **不稳定**：早期的浏览器都是通过插件来实现视频、游戏等功能，插件、渲染引擎等都运行在浏览器进程之中，一个意外崩溃就会导致整个浏览器的奔溃。
>2. **不流畅**：因为所有页面的功能模块都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。
>3. **不安全**：不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题。

# 过渡阶段的发展
>**背景**：国产浏览器都采用多标签的形式，其中的一个标签页面的卡顿都会影响到整个浏览器。
>
>因为卡顿，国内浏览器就开始尝试支持**页面多线程**，也就是让部分页面运行在单独的线程之中，意味着每个线程拥有单独的JavaScript执行环境，和Cookie环境。

问题就来了：比如A站点页面登陆一个网站，保存了一些Cookie数据到磁盘上，再在当前线程环境中保存部分Session数据，由于Session是不需要保存到硬盘上的，所以Session只会保存在当前的线程环境中。这时候再打开另外一个A站点的页面，假设这个页面在另外一个线程中里面，那么它首先读取硬盘上的Cookie信息，但是，由于Session信息是保存在另外一个线程里面的，无法直接读取，这样就要实现一个**Session同步**的问题。

>后来，Session问题解决了，但是假死的问题依然有，因为进程内使用了一个窗口，这个窗口是依附到浏览器主窗口之上的，所以他们公用一套**消息循环机制**，如果一个窗口卡死了，整个浏览器也会卡死。
国产浏览器又出了一招，就是把页面做成一个单独的弹窗，如果这个页面卡死了，就把这个弹窗给隐藏掉。

**！！！**为什么Chrome中的一个页面假死不会影响到主窗口呢？

>这是因为chrome输出实际上是图片，然后浏览器端把图片贴到自己的窗口上去，在Chrome的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。

# 多进程浏览器
随着 Chrome 浏览器的发布，浏览器架构终于来到了多进程的时代。
其中 **Chrome 浏览器的进程架构**如下：

![早期多进程架构](../../../images/chorme1.png)
<center style="font-size:14px;color:#C0C0C0;">早期多进程架构</center> 

![目前多进程架构](../../../images/chorme2.png)
<center style="font-size:14px;color:#C0C0C0;">目前多进程架构</center> 

**Chrome架构**包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络进程、多个渲染进程和多个插件进程。作用如下：
>**Browser进程（浏览器进程）**：浏览器的主进程。主要有以下几个作用：负责浏览器页面的显示与页面交互；负责个页面的管理（创建和销毁其他进程）；将 Renderer 进程得到的内存中的 Bitmap ，绘制到用户页面上；网络资源的管理，下载等。
>
>**第三方插件进程**：主要负责插件的运行，每种类型的插件都对应着一个进程，只有当使用该插件时才会创建该进程，这样就做到了隔离插件的效果，保证插件的崩溃不会影响到浏览器以及页面。
>
>**GPU进程**：为了实现 3D CSS 的效果，GPU进程成为了浏览器的普遍需求，因此Chrome浏览器也在其多进程的架构上引入了GPU进程。
>
>**浏览器渲染进程**，也就是浏览器内核，Renderer进程，内部是多线程的：默认每个Tab页面都是一个进程，互相不影响。主要作用是页面渲染，脚本执行，事件处理等。
>
>**网络进程**：主要负责页面的网络资源的加载，之前是作为一个模块运行在浏览器进程中的，最近几年才独立出来，作为一个单独的进程存在。

## **重点**  浏览器内核（渲染进程）

* 浏览器内核分为两个部分：渲染引擎，JS引擎。
* 由于JS引擎越来越独立，浏览器内核就倾向于单指渲染引擎。

常见引擎
+ 渲染引擎
    + firefox使用gecko引擎
    + IE使用Trident引擎
    + 2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge,使用edge引擎
    + chrome\safari\opera使用webkit引擎
    + 3年chrome和opera开始使用Blink引擎
+ JS引擎
    + 老版本IE使用Jscript引擎
    + IE9之后使用Chakra引擎
    + edge浏览器仍然使用Chakra引擎
    + firefox使用monkey系列引擎
    + safari使用的SquirrelFish系列引擎
    + Opera使用Carakan引擎
    + chrome使用V8引擎。nodeJs其实就是封装了V8引擎


对于前端来说，页面的渲染、JS的执行、事件的循环都在这个进程中进行。 **浏览器的渲染进程是多线程的**。 浏览器的渲染进程包括哪些线程：

>1.GUI渲染线程
>* 负责渲染浏览器界面，解析HTML、CSS，构建DOM Tree，css Tree和RenderObject树，布局和绘制
>* 当界面需要重绘（Repaint)或由于某种操作引发回流（reflow)时，该线程就会执行
>* **GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中，**等到JS引擎空闲时**立即被执行。
>
>2.JS引擎线程(主线程、单线程)
>* 也称JS内核，负责处理JS脚本程序。例如V8引擎
>* JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（Renderer进程）中无论什么时候都只有一个JS引擎线程在运行JS程序
>* **GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，页面渲染就不连贯。
>
>3.事件触发线程
>* 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解为：JS引擎自己都忙不过来，需要浏览器另开线程协助）
>* 当JS引擎执行代码块和setTimeout时（也可来自浏览器内核的其他线程，如鼠标点击），会将对应事件任务添加到事件线程(事件队列)中
>* 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的尾部，等待JS引擎的处理
>* **由于JS是单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）**
>
>4.定时触发器线程
>* setInterval和setTimeout所在的线程
>* 浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性
>* 因此通过定时触发器线程来计时并触发定时，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行
>* **W3C在HTML标准中规定，要求setTimeout中低于4ms的时间间隔算4ms**
>
>5.异步http请求线程
>* XMLHttpRequest在连接后是通过浏览器新开一个线程请求
>* 在检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行
>
>6.EventLoop轮询处理线程
>
>上面我们已经知道了，有3个东西：
>* 主线程，处理同步代码；
>* 异步线程，处理异步代码；
>* 消息队列，存储着异步成功后的回调函数，一个静态存储结构。
>
>但是，它们3个互相怎么交流的？这需要一个中介去专门去沟通它们3个，而这个中介，就是EventLoop轮询处理线程

![js引擎机制.png](../../../images/chorme7.png)

<font style="color: #ec7907;">为什么JavaScript是单线程？</font>

* JavaScript的单线程，与它的用途有关。JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
* 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。

### 同步和异步

* 同步在发出调用后，没有结果前是不返回的，一旦调用返回，就得到返回值。调用者会主动等待这个调用结果。
* 异步是发出调用后，调用者不会立刻得到结果，而是被调用者通过状态或回调函数来处理这个调用。

**任务队列：**
因为JavaScript是单线程的。就意味着所有任务都需要排队，前一个任务结束，后一个任务才能执行。
主线程挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再把挂起的任务继续执行下去。于是有了同步任务和异步任务。

>* 同步任务 是指在主线程上执行的任务，只有前一个任务执行完毕，下一个任务才能执行。
>* 异步任务 是指不进入主线程，而是进入任务队列（task queue）的任务，只有主线程任务执行完毕，任务队列的任务才会进入主线程执行。

### 宏任务和微任务（异步任务的两种）

<mark>macro-task</mark>(宏任务，优先级低，先定义的先执行): ajax，setTimeout，setInterval，setImmediate，I/O，事件，postMessage，MessageChannel（用于消息通讯）


<mark>micro-task</mark>(微任务，优先级高，并且可以插队，不是先定义先执行): process.nextTick(Node.js 环境)，Object.observe(已废弃), MutationObserver（Promise本身是同步的，Promise.then是异步的）

**宏任务和微任务的区别**：微任务是会被加入本轮循环的，而宏任务都是在次轮循环中被执行。简单就是说，微任务会比宏任务提前执行

### 浏览器的事件环(Event Loop)
JavaScript是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。

*简单概括为*：执行同步代码 ==> **检查微任务并执行** ==> 执行宏任务1 ==> **检查微任务并执行** ==> 执行宏任务2 ==> **检查微任务并执行** ==> 执行宏任务3 ......

![Event Loop.png](../../../images/chorme8.png)

每次执行栈中的代码就是一个**宏任务(task)**，而消息队列中的任务会按顺序放到下一次的**宏任务(task)中，每个宏任务(task)在执行时，V8 都会重新创建栈，然后随着宏任务(task)中函数调用，栈也随之变化，最终，当该宏任务(task)执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务(task)**。

而浏览器会在一个 **宏任务(task)** 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染如图：

![Event Loop.png](../../../images/chorme13.png)

由于主线程执行消息队列中宏任务的时间颗粒度太粗了（主要中间有一次渲染过程），无法胜任一些对精度和实时性要求较高的场景，所以又引入了**promise**机制也就是微任务如图:

![Event Loop.png](../../../images/chorme14.png)

<!-- 从上图看出：
1.主线程运行的时候产生堆（heap）和栈（stack）
2.栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（例如：click，load，done）
3.只要栈中的代码执行完毕，主线程就会去读取"任务队列"，将队列中的事件放到执行栈中依次执行。
4.主线程继续执行，当再调用外部API时又加入到任务队列中，等主线程执行完毕又会接着将任务队列中的事件放到主线程中。
5.上面整个过程是循环不断的。 -->

#### 举例：

![Event Loop.png](../../../images/chorme9.png)

``` javascript
console.log('script start');
setTimeout(function() {
    console.log('setTimeout1');
}, 10);
Promise.resolve().then(function() {
    console.log('promise1');
}).then(function() {
    console.log('promise2');
});
setTimeout(function() {
    console.log('setTimeout2');
}, 0);
console.log('script end');

```
### 浏览器渲染流程

* ```Browser```主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源），随后将该任务通过```RendererHost```接口传递给Render渲染进程
* ```Render```渲染进程的```Renderer```接口收到消息，简单解释后，交给渲染线程```GUI```，然后开始渲染
* ```GUI```渲染线程接收请求，加载网页并渲染网页，这其中可能需要```Browser```主进程获取资源和需要GPU进程来帮助渲染
* 当然可能会有```JS```线程操作```DOM```（注意：这可能会造成回流并重绘）
* 最后```Render```渲染进程将结果传递给```Browser```主进程
* ```Browser```主进程接收到结果并将结果绘制出来

![浏览器渲染流程.png](../../../images/chorme10.png)

浏览器内核拿到内容后，渲染大概可以划分成以下几个步骤：
* 解析html创建dom树
* 解析css构建css树
* 运行JS脚本，等到JS文件下载完成后，通过DOM API 和CSS API 操作DOM Tree和CSS Rule Tree，然后结合Css 树和DOM合并成render树。
* 布局render树（layout/reflow），负责各元素尺寸、位置的计算
* 绘制render树（paint)，绘制页面像素信息
* 浏览器将各层的信息发送给GPU进程，GPU会将各层合成（composite）显示在页面上，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了

![渲染过程.png](../../../images/chorme11.png)

PS：[图解Chrome架构](https://blog.csdn.net/qq_39111085/article/details/103776844)

PS：[Chrome底层原理](https://www.cnblogs.com/fuguy/p/13073884.html)

单进程浏览器遗留问题的**解决**：
>1. **不稳定**：由于进程是相互隔离的，所以当一个页面或者插件崩溃 时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃。
>2. **不流畅**：在多进程的架构下，JavaScript 只是运行在自己的渲染进程中的，因此即使 JavaScript 代码阻塞了渲染进程，受到影响的也只是当前所渲染的页面，脚本运行也是同样的道理。而对于常常引发性能问题的内存泄漏，在这种架构下，关闭一个页面，会将整个渲染进程给关闭，这时候操作系统就会回收这个进程所占用的内存，也就会不会存在内存泄漏的问题了。
>3. **不安全**：多进程架构的可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行， 但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据（文档、桌面）。沙箱里面，即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

多进程的浏览器存在着一些**问题**：
* 资源占用更多了
* 更为复杂的体系结构

# SOA架构

**服务化**：在2016年Chrome官方团队使用**面向服务**的架构的思想设计了新的Chrome架构，也就是说Chrome整体架构会朝向现代操作系统所采用的面向服务的架构方向发展，原来的各种模块都会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过IPC来通信 ，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现chrome简单稳定，高速安全的目标 。

Chrome最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务。

![Chrome面向服务的架构进程模型图.png](../../../images/chorme3.png)
<center style="font-size:14px;color:#C0C0C0;">Chrome面向服务的架构进程模型图</center> 

**弹性架构**：将浏览器程序的每个部分，作为一项服务运行，然后根据情况而定，来将其拆分为不同的流程或汇总为同一个流程，是个资源的动态调配整合。
e.g.  若浏览器在高性能电脑上运行时，可能会将每个服务拆分为不同的进程，从而提供更高的稳定性。但如果不具备此条件，设备资源受到约束，多个服务就可能会被整合到一个进程当中，从而节省内存占用。

![在资源不足的设备上将服务合并到浏览器进程中.png](../../../images/chorme4.png)
<center style="font-size:14px;color:#C0C0C0;">在资源不足的设备上将服务合并到浏览器进程中</center> 

**总结**：
PS：[单进程与多进程优缺点](http://www.mamicode.com/info-detail-641220.html)
### 问题小结

**为什么单进程浏览器当时没有采用安全沙箱？**
>因为一个进程使用了安全沙箱后，该进程的系统权限受限，在单进程浏览器中，这将会影响主进程的权限。

**打开Chrome浏览器一个Tab页面，至少会出现几个进程？**
>根据目前的Chrome架构:1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程；
>
>   1. 页面中有iframe的话，跨站点 iframe 在单个渲染器进程中运行（站点隔离），并在不同站点之间共享内存空间。
>   ![image.png](../../../images/chorme5.png) 
>   
>   2. 有插件的话，插件也会开启进程
>
>   3. 多个页面属于同一站点，并且从a打开b页面，会共用一个渲染进程
>
>   4. 装了扩展的话，扩展也会占用进程

所以打开 1 个页面至少需要3~4个进程：1 个浏览器(Browser)主进程、1 个 GPU 进程以及 1 个渲染进程，如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

这些进程都可以通过Chrome任务管理器来查看

![举例.png](../../../images/chorme6.png)
<center style="font-size:14px;color:#C0C0C0;">举例</center> 


**多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况？**
>Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。那么同一个站点的其中一个页面崩溃了，那么其他页面也会跟着一起崩溃。
