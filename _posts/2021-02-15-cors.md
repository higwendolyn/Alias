---
layout: post
title: "浏览器-—跨域的几种解决方案"
category: '浏览器'
---

学习下，如何优雅的跨域~

![image.png](../../../images/cors1.png)

## 什么是跨域

### 同源策略及其限制

**同源策略**："协议+域名+端口"三者相同（两个不同的域名指向同一个ip地址，也非同源）

> 缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。

同源策略限制内容有：

* Cookie、LocalStorage、IndexedDB 等存储性内容
* DOM 节点
* AJAX 请求发送后，结果被浏览器拦截了

有三个标签是允许跨域加载资源：

* ```<img src=XXX>```
* ```<link href=XXX>```
* ```<script src=XXX>```

**当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。

### 常见跨域场景

URL|说明|是否允许通信
--|--|--
<font style="display: block;">http://www.a.com/a.js</font><font style="display: block;">http://www.a.com/b.js</font>|同一域名下|允许
<font style="display: block;">http://www.a.com/lab/a.js</font><font style="display: block;">http://www.a.com/script/b.js</font>|同一域名下不同文件夹|允许
<font style="display: block;">http://www.a.com:8000/a.js</font><font style="display: block;">http://www.a.com/b.js</font>|同一域名，不同端口|不允许
<font style="display: block;">http://www.a.com/a.js</font><font style="display: block;">https://www.a.com/b.js</font>|同一域名，不同协议|不允许
<font style="display: block;">http://www.a.com/a.js</font><font style="display: block;">http://70.32.92.74/b.js</font>|域名和域名对应IP|不允许
<font style="display: block;">http://www.a.com/a.js</font><font style="display: block;">http://script.a.com/b.js</font>|主域相同，子域不同|不允许
<font style="display: block;">http://www.a.com/a.js</font><font style="display: block;">http://a.com/b.js</font>|同一域名，不同二级域名（同上）|不允许
<font style="display: block;">http://www.cnblogs.com/a.js</font><font style="display: block;">http://www.a.com/b.js</font>|不同域名|不允许

---

* 协议和端口造成的跨域问题“前台”无法处理
* 请求跨域了，那么请求发出了没？
> 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

## 跨域解决方案

### jsonp

#### JSONP原理

利用 ```<script>``` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。

JSONP请求一定需要对方的服务器做支持才可以。

#### JSONP优缺点

优点： 简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题

缺点：仅支持get方法具有局限性,不安全可能会遭受XSS攻击

#### JSONP的实现

向```http://localhost:3000/say?wd=Iloveyou&callback=show```这个地址请求数据，然后后台返回```show('XXX')```，最后会运行```show()```这个函数，打印出'XXX'

```javascript
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    params = { ...params, callback } // wd=b&callback=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}
jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})
```

### CORS

CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

