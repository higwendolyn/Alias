---
layout: post
title: "HTTP 请求"
category: '网络'
---

讲解HTTP请求，从输入url到页面呈现的过程.

## HTTP 请求
浏览器中的 HTTP 请求流程

![image.png](../../../images/http1.png) 
<center style="font-size:14px;color:#C0C0C0;">整体流程</center> 

>浏览器中的 HTTP 请求从发起到结束一共经历：
>* 构建请求
>* 查找缓存
>* 准备 IP 和端口
>* 等待 TCP 队列
>* 建立 TCP 连接
>* 发起 HTTP 请求
>* 服务器处理请求
>* 服务器返回请求和断开连接

## 浏览器端发起 HTTP 请求流程

### 1. 构建请求

首先，浏览器构建**请求行**信息（如下所示），构建好后，浏览器准备发起网络请求。
```
GET /index.html HTTP1.1
```
### 2. 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，**浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术**。

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处：   
+ 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
+ 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果缓存查找失败，就会进入网络请求过程了

### 3. 准备 IP 地址和端口

**HTTP 和 TCP 的关系**：浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的。

![image.png](../../../images/http2.png) 
<center style="font-size:14px;color:#C0C0C0;">HTTP 网络请求</center> 

建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。

>域名系统（DNS）：域名和 IP 地址做一一映射关系。

>**IP地址**：第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。
>
>**端口号**：通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

阮一峰的[DNS 原理入门](http://www.ruanyifeng.com/blog/2016/06/dns.html)

### 4. 等待 TCP 队列

>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

有很多图片资源或者其他支援请求怎么办？

一. 浏览器有连接请求限制，一般浏览器都是最大http连接数被限制在6个，有以下解决方法

　1\. 懒加载，没有浏览到的图片暂不请求

　2\. 小图片比较多，可以用雪碧图、字体图标、base64等，这样可以有效减少连接数

　3\. 连接数限制问题还可以由http2来解决，http2一个站点只有一个连接。每个请求为一个流，每个请求被分为多个二进制帧，不同流中的帧可以交错的发送，实现多路复用。这就解决了连接数限制的问题

[《http2讲解》](https://ye11ow.gitbooks.io/http2-explained/content/)

二、图片过大，传输和渲染比较慢，有以下的处理办法

　1\. 如果是相册之类的可以预加载，在展示当前图片的时候，就加载它的前一个和后一个图片

　2\. 加载的时候可以先加载一个压缩率非常高的缩略图，以提高用户体验

　3\. 使用渐进式jpeg，会提高用户体验

　4\. 如果展示区域小于图片的真实大小，可以在服务端先压缩到合适的尺寸

### 5. 建立 TCP 连接

排队等待结束之后，就可以和服务器握手了。在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式可以看看这篇文章：

[TCP/UDP协议详解](https://juejin.cn/post/TCP/UDP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3)

一个完整的TCP连接生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

![TCP连接生命周期.png](../../../images/http3.png) 
<center style="font-size:14px;color:#C0C0C0;">TCP连接生命周期</center> 

### 6. 发送 HTTP 请求

TCP的连接，是为了保证浏览器跟服务器更好的通信， HTTP 中的数据就是在这个通信过程中传输的。

![HTTP数据.png](../../../images/http4.png) 
<center style="font-size:14px;color:#C0C0C0;">HTTP数据</center> 

**请求行**：

①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。

②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。

③是协议名称及版本号。

**请求头**：

④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。

与缓存相关的规则信息，均包含在header中

**请求体**：

⑤是报文体，它将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&param2=value2”的方式传递请求参数。

**HTTP请求报文头属性**
>**Accept**：告诉服务端，客户端接受什么类型的响应。 如下，报文头相当于告诉服务端，响应类型仅为纯文本数据
>```
>Accept:text/plain 
>```
>Accept属性的值可以为一个或多个MIME类型的值（描述消息内容类型的因特网标准， 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据）
>
>**cookie**：客户端的Cookie就是通过这个报文头属性传给服务端
>```
>Cookie: $Version=1; Skin=new;jsessionid=5F4771183629C9834F8382E23 
>```
>服务端通过jsessionid判断是否隶属于同一个客户端。HTTP请求报文头的Cookie属性的jsessionid的值关联起来（也可以通过重写URL的方式将会话ID附带在每个URL的后面）。
>
>**Referer**：表示这个请求是从哪个URL过来的。假如你通过google搜索出一个商家的广告页面，你对这个广告页面感兴趣，鼠标一点发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值>就是http://www.google.com。
>
>**Cache-Control**：对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。

### 7. 服务器端处理HTTP请求流程

此时你可以理解成HTTP请求信息终于送到到服务器，接下来服务器会根据请求信息来准备相应的内容啦

**7.1 HTTP响应报文**

![HTTP数据.png](../../../images/http5.png) 
<center style="font-size:14px;color:#C0C0C0;">HTTP响应报文</center> 

**响应行**：

①报文协议及版本； 

②状态码及状态描述；

**响应头**：

③响应报文头，也是由多个属性组成；

**响应体**：

④响应报文体，即我们真正要的“干货”


[具有代表性的 HTTP 状态码](https://juejin.im/post/6844903519447678990)

[面试必考之http状态码有哪些](http://hpoenixf.com/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E4%B9%8Bhttp%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B.html)

**7.2 断开连接**

一般情况下，服务器发送完数据后，就要关闭TCP连接。不过有一种情况比较特殊，我们来看看
```
Connection:Keep-Alive
 ```
复制代码如果浏览器或者在服务器中加入其头信息如上面的字段的话，TCP连接会仍然保持，这样子浏览器就可以通过同一个TCP连接发送请求，保存TCP连接可以省下去下次请求需要建立连接的时间，提升资源加载速度。

比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。
### 重定向

你肯定遇到过这样子的情况吧：**当你在浏览器中打开 baidu.com 后，你会发现最终打开的页面地址是 www.baidu.com ** 这就是涉及到了**重定向**

![](../../../images/http6.png) 


> 我们看看响应行返回的状态码301，状态301告诉浏览器，你需要重新转到另外一个网址，需要重定向的地址正式包含在响应头的Location字段中。接下啦，浏览器获取Location字段中的地址，重新导航，这也就是完整的重定向的执行流程。

这解释了为什么输入baidu.com后，最终打开的是www.baidu.com

## HTTP 1.0、HTTP 1.1 和HTTP 2.0

## HTTP为什么不安全