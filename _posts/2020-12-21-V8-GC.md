---
layout: post
title: "V8引擎——垃圾回收机制"
---

重点解析V8引擎的**垃圾回收机制**。

本文重点内容是关于V8的垃圾回收机制，以及V8对垃圾回收的优化策略，首先需要对内存结构有一个初步了解。

## 什么是内存

通常我们说的计算机由5个部分组成，控制器、运算器、输出设备、输出设备、**存储器**，而我们说的内存通常属于存储器，而程序运行时CPU需要调用的指令和数据只能通过内存获取（硬盘只有存储功能，执行时会将数据缓存到内存中），所以不管是什么语言的程序，运行时都依赖内存，而内存生命周期基本都是一致的：

* 分配所需要的内存
* 使用分配到的内存（读、写）
* 不需要时将其释放、归还

## 简述堆和栈
### 什么是堆和栈
在V8引擎中，可以先粗犷的分为两个部分 **栈** 和 **堆**。
那栈指的就是 **调用栈**，首先栈的特点后进先出，同时栈空间是连续的，在需要分配空间和销毁空间操作时，只需要移动下指针，所以非常适合管理函数调用。
而正因为栈空间是连续的，那它的空间就注定是非常有限的，所以不方便存放大的数据，这时我们就使用了 **内存堆** 来管理保存一些大数据。
### 基础类型和引用类型
两种变量类型：**基本类型变量** 和 **引用变量类型**。

>基础变量类型：undefined, null, Number, String, Boolean, Symbol；
>
>引用变量类型：Object、Array、Function等等，而实际上在js中Array、Function这些都是基于Objct的，我们可以理解引用变量类型指的就是Objct。
>
>（这里可能有人会说 null不应该是空指针对象类型吗，typeof null === 'Object'应该算是对象，事实上这里是一个设计上的历史遗留问题，而对V8系统来说无论是null和Undefined都只是一个存在于栈里的固定的值）。
>
>因为基础变量类型的值通常是简单的数据段，占用固定大小的空间，所以会存储在 **栈** 中，而对象大小不定且通常会占用较大空间所以会存储在 **堆** 中，而在栈空间会保存对象存储在堆空间的地址。

我们将一段代码通过一张图来简单看一下。
```
var a = 123;
var b = 'abc';
var c = {x: 1};
var d = 123;
var f = c;
var g = {x: 1};
```
![image.png](../../../images/gc1.png)

基础类型的值在创建时会开辟一块内存空间，将内存地址存储在对应的变量上，如果此时再创建一个基础类型等同于之前创建过的值，会直接将地址存储在新创建的变量上，所以就会有 **a === d** 。

那么如果创建一个对象，就会在堆中开辟一块空间用来存储对象，将内存地址存储在对应的变量上，如果此时创建一个新的变量（f）赋值为之前所创建的存储对象地址的变量（c），那么会将c存储的堆内存地址赋值给f，就会有 **c === f**。

如果此时再创建一个新的对象变量g，就会在堆中再开辟一块空间来创建对象，将地址赋予g，但是即使对象内容一样，地址不同指向的也是两块空间，就会有 **g !== c**。

关于函数调用也很好理解，也是用一段代码一张图来表示如下：
```
function main() {
    func1();
}
function func1() {
    func2();
    func3();
};
function func2() {};
function func3() {};
main();
```
![image.png](../../../images/gc2.png)

在函数间的嵌套调用的过程中外层的函数不会释放，而栈的空间是有限的也有着严格的数量限制，所以在使用递归的时候要注意是否会**溢出**。

## V8内存管理的核心——堆
栈的管理通常比较容易一点，通过上下移动指针来管理即可，而堆的管理相对复杂很多，而我们通常说的垃圾回收等也主要针对堆来说的。

### 堆空间的结构
内存的结构组成：

![image.png](../../../images/gc3.png)

V8引擎初始化内存空间主要将堆内存分为以下几个区域：

* <font style="color: black;">新生代内存区（new space）</font>
新生代内存区会被划分为两个semispace，每个semispace大小默认为16MB也就是说新生代内存区通常只有32MB大小（64位），而这两个semispace分别是from space 和 to space（具体有什么用下文会说），通常新创建的对象会先放入这两个semispace中的一个。


*  <font style="color: black;">老生代内存区（old space）</font>
通常会较为持久的保存对象,也分为两个区域 **old pointer space** 和 **old data space**分别用来存放GC后还存活的指针信息和数据信息。


*  <font style="color: black;">大对象区（large object space）</font>
这里存放体积超越其他区大小的对象，主要为了避免大对象的拷贝，使用该空间专门存储大对象。


*  <font style="color: black;">单元区、属性单元区、Map区（Cell space、property cell space、map space）</font>
Map空间存放对象的Map信息也就是隐藏类(Hiden Class）最大限制为8MB；每个Map对象固定大小，为了快速定位，所以将该空间单独出来。


*  <font style="color: black;">代码区 (code Space)</font>
主要存放代码对象，最大限制为512MB，也是唯一拥有执行权限的内存

### 内存运行的生命周期
堆内存空间分成了有不同功能作用的空间区域，重点了解一下**新生代内存区**和**老生代内存区**。


**新生代内存区**
>假设创建了一个对象 obj，其两个space------ **from space** 和 **to space** 的作用如下：
>* 首先obj会被分配到 **新生代** 中两个space中其中一个space，这里我们假设分配到了from space中。
>* 程序继续执行会不断的向from space中添加新的对象信息，这时from space将要达到了存储的上限（16MB），V8的垃圾回收机制会开始清理from中不再被使用的对象（即没有被指向的对象）。
>* 清理后，将所有仍然存活的对象（我们假设obj还存活），会被复制到to space然后删除所有from space中的对象。
>![image.png](../../../images/gc6.png)
>
>* 这时，程序继续运行，如果有新创建的对象会不断的分配到to space中，当to space快要满了重复执行上面说的复制转移的工作。
>![image.png](../../../images/gc7.png)
>
>也就是说创建的对象会在to space 和 from space 之间转移，也就是所谓的 to --> from, from --> to 的角色互换过程。


**老生代内存区**
>现在继续上文说的那个对象 obj：
>* 经过程序一段时间运行后的obj依然存活在新生代内存区，终于满足了**晋升条件**，便转移到了老生代内存区。
>* 又过了一段时间对象 obj 终于不被引用了，同时老生代内存区域空间也被占用了很多的空间，V8就会在老生代里面进行遍历，发现了对象 obj 已经不被引用了，于是给他打了个标记。
>* 由于V8是单线程的执行机制，V8为了避免一次清除占用太多时间，会给这批打了标记的待清理对象进行**分批回收**，至此这个对象就在内存中释放掉了。

## 垃圾回收

```概念```：比如V8引擎在执行代码的过程中遇到了一个函数，那么我们会创建一个函数执行上下文环境并添加到 **调用栈** 顶部，函数的作用域里面包含了函数中所有的变量信息，在执行过程中我们分配内存创建这些变量，当函数执行完毕后函数作用域会被销毁，那么这个作用域包含的变量也就失去了作用，那么销毁它们回收内存的过程，我们就叫做垃圾回收。

```隐患```：垃圾回收的过程是v8引擎自动帮我们执行的，在绝大部分情况下v8都能很好的完成这个过程，但是作为一段程序，能帮我们cover住的情况是有限的，所以一旦我们代码不够严谨，就会引发内存泄露。

javascript语言是单线程，意味着执行的代码都是按顺序执行的且同一时间也只能处理一个任务。那么V8在执行垃圾回收任务的时候，其他的任务都将处于等待状态，直到垃圾回收任务结束后才能执行其他任务，如果垃圾回收任务的执行时间过长就不可避免的对用户体验造成影响，V8为了减少这种影响也做了一系列的优化。

## 垃圾回收器

```代际假说```（The Generational Hypothesis）是垃圾回收领域中的一个重要术语， V8的垃圾回收的策略也是建立在该假说的基础之上。

代际假说主要有两个特点：
* 大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问。
* 不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。

基于这个这个假说 **V8** 才会把堆分为新生代和老生代两个区域，同时设计了两个垃圾回收器：
* **副垃圾回收器** -Minor GC（Scavenging）负责新生代区域的垃圾回收
* **主垃圾回收器** -Major GC负责老生代区域的垃圾回收

### 副垃圾回收器(Scavenge)
副垃圾回收器主要用来回收**新生代的垃圾**，通常我们新创建的对象都会先分配到新生代内存区中。

**Scavenge算法**：新生代内存区会分成两个部分（space），**from space** 和 **to space** , 这两个区域本质都是一样的，都拥有两个状态 **工作状态** 和 **空闲状态**且当一个为工作状态的时候另一个一定是空闲状态。

![image.png](../../../images/gc4.png)

>新创建一个对象：
>* 会向内存堆中的新生代去分配，假如此时新生代中的**from spcae** 是工作状态，那么对象会分配到**from space** 中。
>* 经过一段时间程序运行，**from space**的的内存即将达到存储的上限。
>* V8引擎此时执行一次垃圾清理操作，会将**from space**中不再使用的对象（根节点无法遍历到的对象）进行标记。
>* 会将未被标记的对象进行复制，复制到空闲状态的**to space**中并且有序的重新排列起来，再将**from space**进行清空操作，同时将**from space** 标记为空闲状态将**to space**标记为工作状态。
>
>这是所谓的**置换**也可以说是**翻转**过程，因为这种复制操作需要时间成本，所以新生代的空间往往并不大，所以执行的也较为频繁。

```晋升机制```：为了解决某些对象一直在被使用会持续的积压在新生代区域，V8采用了 **晋升机制** 将满足条件的对象放到老生代内存区中存储，释放新生代内存区域的空间。

**晋升机制的条件（同时满足）**：
* 经历过一次Scavenging算法，且并未被标记清除的，也就是过一次翻转置换操作的对象。
* 在进行翻转置换时，被复制的对象大于to space空间的25%。(from space 和 to space 一定是一样大的)
晋升后的对象分配到老生代内存区，便由老生代内存区来管理。

### 主垃圾回收器(Mark-Sweep & Mark-Compact)
主垃圾回收器：用来回收老生代的垃圾，通常会有在*新生代晋升*后的对象以及*初始占用空间很大*的对象会存储在老生代内存区。

```过程```：主垃圾回收器会先使用**标记 - 清除**（Mark-Sweep）的算法、**标记 - 整理**（Mark-Compact） 算法进行垃圾回收进行垃圾回收。
#### 标记 - 清除（Mark-Sweep）

* **标记过程**：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
* **垃圾清除**：它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。

![image.png](../../../images/gc5.png)

通过这种标记清除的方式清理内存会产生大量不连续的内存碎片，当我们想要存储一个大的对象的时候就可能没有足够的空间，所以还需要 **标记 - 整理（Mark-Compact）** 算法进行垃圾回收。
。

#### 标记 - 整理（Mark-Compact）

主要分两步：
* 首先同样是标记过程。
* 将未标记的对象（存活对象）进行左移，移动完成后清理边界外的内存。

![image.png](../../../images/gc8.png)

V8通过**标记 - 清除**（Mark-Sweep） 以及 **标记 - 整理**（Mark-Compact） 两种算法对老生代内存区进行垃圾回收，这就是主垃圾回收器的主要工作。

## 全停顿

已经知道V8是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于JavaScript是运行在**主线程**之上的，一旦执行垃圾回收算法，都需要**将正在执行的JavaScript脚本停顿下来**，待垃圾回收完毕后再回复脚本执行。

![image.png](../../../images/gc9.png)

在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。

## 垃圾回收优化策略（Orinoco）

上文中描述的V8的两个垃圾回收器所采用的方法其实在具有垃圾回收机制的编程语言中都是非常常见的。

评价垃圾回收机制的一个重要标准：执行垃圾回收时主线程挂起的时间，而V8为了优化这一部分体验（减少主线程挂起的时间），启动代号为**Orinoco的垃圾回收器项目**。

Orinoco共实现了三个优化

* 并行垃圾回收 (parallel)
* 增量垃圾回收 (incremental)
* 并发垃圾回收 (concurrent)

### 并行垃圾回收

**前提**：**新生代内存区** 和 **老生代内存区**根据之前讲过的垃圾回收机制，我们可以确定在新生代内存区中的对象和老生代内存区中的对象是完全不同的。

新生代在执行 **标记->复制->清理** 的操作和老生代执行 **标记->清理->紧凑** 的操作是没有任何依赖关系的。

**策略**：于是Orinoco判断将没有依赖关系的垃圾清理逻辑（不止上述一种）通过并行执行的方式来优化减少执行垃圾回收占用主进程的时间。

所以Orinoco只需要开启辅助几个辅助进程就可以同时完成垃圾清理的工作如下图：

![image.png](../../../images/gc10.png)
### 增量垃圾回收

虽然并行垃圾回收的并行机制可以有效的减少主进程的占用，但是面对一个大的对象一次执行标记也要话很长的时间。

从2011年开始V8引入了**增量标记机制**，也就是增量垃圾回收机制。

![image.png](../../../images/gc11.png)

将一次大的任务分解为更小的块，允许应用程序在块之间运行。

增量标记的算法，增量回收是并发的（concurrent），要实现增量执行，需要满足：
* 垃圾回收可以被随时**暂停**和**重启**，暂停时需要**保存当时的扫描结果**，等下一波垃圾回收来了之后，才能继续启动。
* 在暂停期间，被标记好的垃圾数据如果被JavaScript代码**修改**了，那么垃圾回收器需要能够正确地处理。

#### V8 是如何实现垃圾回收器的暂停和恢复执行的？

在没有采用增量算法之前，V8 使用**黑色**和**白色**来标记数据。在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器从 GC Roots 出发，将所有能访问到的数据标记为黑色。

遍历结束之后，黑色就是**活动数据**，白色数据就是**垃圾数据**。

![image.png](../../../images/gc15.png)

垃圾回收器执行了一小段增量回收后，被 V8 暂停了，然后主线程执行了一段 JavaScript 代码，然后垃圾回收器又被恢复了，它到底是从 A 节点开始标记，还是从 B 节点开始执行标注过程呢？

![image.png](../../../images/gc16.png)

#### 三色标记法

于是V8采用了 **标记位** 和 **标记工作表** 来实现标记。

标记位用来标记三种颜色：**白色(00)**、**灰色(10)**、**黑色(11)**，

>**黑色**：这个节点被 GC Root 引用到了，而且该节点的子节点都已经**标记完成**了 ;
>
>**灰色**：这个节点被 GC Root 引用到，但子节点还没被垃圾回收器标记处理，也表明目前**正在处理**这个节点。
>
>**白色**：这个节点**没有被访问**到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回。
>
>标记流程：
>* 最初状态所有的对象都是 **白色** 也就是未被根节点引用到的对象。
>* 当垃圾回收程序发现一个对象被引用会将这个对象标记为 **灰色** 并将其推入到 **标记工作表** 中。
>* **标记工作表** 会访问所有自身的 **灰色** 对象，并访问该对象的所有子对象（不管有没有子对象），结束后会将该对象标记为**黑色**。
>* **标记工作表** 会持续的被注入灰色的对象（每发现一个新的要标记的对象都会注入到标记工作表中）
>* 如果 **标记工作表** 中 没有了灰色 的对象，那么代表所有的对象都是 **黑色** 或者 **白色**，之后可以放心的清理掉 **白色** 的对象。

垃圾回收程序从根节点开始标记（将灰色推入到标记工作表）

![image.png](../../../images/gc12.png)

遍历处理（垃圾回收程序标灰，标记工作表标黑）

![image.png](../../../images/gc13.png)

完成后的最终形态

![image.png](../../../images/gc14.png)
### 并发垃圾回收

### 空闲时垃圾回收


## 参考文章
[V8引擎详解（六）——内存结构](https://juejin.cn/post/6844904175868837901)

[V8引擎详解（七）——垃圾回收机制](https://juejin.cn/post/6844904182512615432#comment)