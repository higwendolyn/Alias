---
layout: post
title: "JS基础---this 指向问题"
category: 'JavaScript系列文章'
---

理解this 指向问题~

## this 作用

this提供了一种更优雅的方法来隐式'传递'一个对象的引用，因此可以将API设计得更加简洁并且易于复用。

## this 的四种绑定规则

### 默认绑定

**规则**：在非严格模式下，默认绑定的```this```指向全局对象，严格模式下```this```指向```undefined```

```javascript
function foo() {
  console.log(this.a); // this指向全局对象
}
var a = 2;
foo(); // 2
function foo2() {
  "use strict"; // 严格模式this绑定到undefined
  console.log(this.a); 
}
foo2(); // TypeError:a undefined
```

```javascript
function foo() {
  console.log(this.a); // foo函数不是严格模式 默认绑定全局对象
}
var a = 2;
function foo2(){
  "use strict";
  foo(); // 严格模式下调用其他函数，不影响默认绑定
}
foo2(); // 2
```

对于默认绑定来说，**决定this绑定对象的是函数体是否处于严格模式**，严格指向undefined，非严格指向全局对象。
### 隐式绑定

**规则**：函数在调用位置，是否有上下文对象，如果有，那么```this```就会隐式绑定到这个对象上。

```javascript
function foo() {
    console.log(this.a);
}
var a = "Oops, global";
let obj2 = {
    a: 2,
    foo: foo
};
let obj1 = {
    a: 22,
    obj2: obj2
};
obj2.foo(); // 2 this指向调用函数的对象
obj1.obj2.foo(); // 2 this指向最后一层调用函数的对象
    
// 隐式绑定丢失
let bar = obj2.foo; // bar只是一个函数别名 是obj2.foo的一个引用
bar(); // "Oops, global" - 指向全局
```

<font style="color: #ec7907;">隐式绑定丢失</font>

隐式绑定丢失的问题：**实际上就是函数调用时，并没有上下文对象，只是对函数的引用**，所以会导致隐式绑定丢失。

传入回调函数中，这种情况更加常见，并且隐蔽:

```javascript
test(obj2.foo); // 传入函数的引用，调用时也是没有上下文对象。
```

### 显式绑定

隐式绑定会丢失，我们可以在**某个对象上强制调用函数，从而将this绑定在这个对象上**。

**规则**：我们可以通过```apply```、```call```、```bind```将函数中的```this```绑定到指定对象上。

```javascript
function foo() {
    console.log(this.a);
}
let obj = {
    a: 2
};
foo.call(obj); // 2
```

<font style="color: #ec7907;">传入的不是对象</font>

如果你传入了一个原始值(```字符串```,```布尔类型```，```数字类型```)，来当做```this```的绑定对象，这个原始值转**换成它的对象形式**。

如果你把```null```或者```undefined```作为```this```的绑定对象传入```call```/```apply```/```bind```，这些值会在调用时被忽略，实际应用的是默认绑定规则。

### new绑定

new的时候会做哪些事情：

* **创建一个全新的对象**。
* 这个新对象会被执行 ```[[Prototype]]``` 连接。
* 这个新对象会绑定到函数调用的```this```。
* 如果函数没有返回其他对象，那么```new```表达式中的函数调用会自动返回这个新对象。

**规则**：使用构造调用的时候，```this```会自动绑定在```new```期间创建的对象上。

```javascript
function foo(a) {
  this.a = a; // this绑定到bar上
}
let bar = new foo(2);
console.log(bar.a); // 2
```

## this 四种绑定规则的优先级

```javascript
obj.foo.call(obj2); // this指向obj2 显式绑定比隐式绑定优先级高。
new obj.foo(); // thsi指向new新创建的对象 new绑定比隐式绑定优先级高。
```

<font style="color: red;">显式绑定 > 隐式绑定 > 默认绑定</font>

<font style="color: red;">new绑定 > 隐式绑定 > 默认绑定</font>

## 箭头函数的 this（不会使用上述的四条规则）

**箭头函数的this规则**

1. 箭头函数中的```this```继承于它外面第一个不是箭头函数的函数的```this```指向。
2. 箭头函数的 ```this``` 一旦绑定了上下文，就不会被任何代码改变。

```javascript
function foo() {
  return () => {
    console.log(this.a);
  };
}
let obj1 = {
  a: 2
};
let obj2 = {
  a: 22
};
let bar = foo.call(obj1); // foo this指向obj1
bar.call(obj2); // 输出2 这里执行箭头函数 并试图绑定this指向到obj2
```

## 总结

调用方式|this指向
--|--
普通函数调用|window
构造函数调用|实例对象 原型对象里面的方法也指向实例对象
对象方法调用|该方法所属对象
事件绑定方法|绑定事件对象
定时器函数|window
立即执行函数|window

## 参考文章

[你不知道的js中关于this绑定机制的解析[看完还不懂算我输]](https://juejin.cn/post/6844903630592540686#heading-3)

